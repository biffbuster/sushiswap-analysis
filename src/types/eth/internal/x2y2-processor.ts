/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides } from "ethers";
import { Networkish } from "ethers/providers";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  TypedCallTrace,
  getNetworkFromCtxOrNetworkish,
} from "@sentio/sdk/eth";
import { BaseContext } from "@sentio/sdk";
import { EthFetchConfig } from "@sentio/protos";

import { X2y2, X2y2__factory } from "./index.js";
import {
  CompoundEvent,
  CompoundEventFilter,
  DepositEvent,
  DepositEventFilter,
  NewRewardsPerBlockEvent,
  NewRewardsPerBlockEventFilter,
  WithdrawEvent,
  WithdrawEventFilter,
} from "./X2y2.js";

export interface NUMBER_PERIODSCallObject {}

export type NUMBER_PERIODSCallTrace = TypedCallTrace<
  [],
  NUMBER_PERIODSCallObject
>;

export interface PRECISION_FACTORCallObject {}

export type PRECISION_FACTORCallTrace = TypedCallTrace<
  [],
  PRECISION_FACTORCallObject
>;

export interface START_BLOCKCallObject {}

export type START_BLOCKCallTrace = TypedCallTrace<[], START_BLOCKCallObject>;

export interface AccTokenPerShareCallObject {}

export type AccTokenPerShareCallTrace = TypedCallTrace<
  [],
  AccTokenPerShareCallObject
>;

export interface CalculatePendingRewardsCallObject {
  user: string;
}

export type CalculatePendingRewardsCallTrace = TypedCallTrace<
  [string],
  CalculatePendingRewardsCallObject
>;

export interface CurrentPhaseCallObject {}

export type CurrentPhaseCallTrace = TypedCallTrace<[], CurrentPhaseCallObject>;

export interface DepositCallObject {
  amount: bigint;
}

export type DepositCallTrace = TypedCallTrace<[bigint], DepositCallObject>;

export interface EndBlockCallObject {}

export type EndBlockCallTrace = TypedCallTrace<[], EndBlockCallObject>;

export interface HarvestAndCompoundCallObject {}

export type HarvestAndCompoundCallTrace = TypedCallTrace<
  [],
  HarvestAndCompoundCallObject
>;

export interface LastRewardBlockCallObject {}

export type LastRewardBlockCallTrace = TypedCallTrace<
  [],
  LastRewardBlockCallObject
>;

export interface RewardPerBlockForOthersCallObject {}

export type RewardPerBlockForOthersCallTrace = TypedCallTrace<
  [],
  RewardPerBlockForOthersCallObject
>;

export interface RewardPerBlockForStakingCallObject {}

export type RewardPerBlockForStakingCallTrace = TypedCallTrace<
  [],
  RewardPerBlockForStakingCallObject
>;

export interface StakingPeriodCallObject {}

export type StakingPeriodCallTrace = TypedCallTrace<
  [bigint],
  StakingPeriodCallObject
>;

export interface TokenSplitterCallObject {}

export type TokenSplitterCallTrace = TypedCallTrace<
  [],
  TokenSplitterCallObject
>;

export interface TotalAmountStakedCallObject {}

export type TotalAmountStakedCallTrace = TypedCallTrace<
  [],
  TotalAmountStakedCallObject
>;

export interface UpdatePoolCallObject {}

export type UpdatePoolCallTrace = TypedCallTrace<[], UpdatePoolCallObject>;

export interface UserInfoCallObject {}

export type UserInfoCallTrace = TypedCallTrace<[string], UserInfoCallObject>;

export interface WithdrawCallObject {
  amount: bigint;
}

export type WithdrawCallTrace = TypedCallTrace<[bigint], WithdrawCallObject>;

export interface WithdrawAllCallObject {}

export type WithdrawAllCallTrace = TypedCallTrace<[], WithdrawAllCallObject>;

export interface X2y2TokenCallObject {}

export type X2y2TokenCallTrace = TypedCallTrace<[], X2y2TokenCallObject>;

const templateContract = X2y2__factory.connect("0x0", DummyProvider);

export class X2y2ContractView extends ContractView<X2y2> {
  constructor(contract: X2y2) {
    super(contract);
  }

  async NUMBER_PERIODS(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("NUMBER_PERIODS()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async PRECISION_FACTOR(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("PRECISION_FACTOR()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async START_BLOCK(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("START_BLOCK()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async accTokenPerShare(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("accTokenPerShare()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async calculatePendingRewards(
    user: string,
    overrides?: Overrides
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction(
        "calculatePendingRewards(address)"
      )(user, overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async currentPhase(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("currentPhase()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async endBlock(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("endBlock()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async lastRewardBlock(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("lastRewardBlock()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async rewardPerBlockForOthers(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("rewardPerBlockForOthers()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async rewardPerBlockForStaking(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("rewardPerBlockForStaking()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async stakingPeriod(
    arg0: BigNumberish,
    overrides?: Overrides
  ): Promise<
    [bigint, bigint, bigint] & {
      rewardPerBlockForStaking: bigint;
      rewardPerBlockForOthers: bigint;
      periodLengthInBlock: bigint;
    }
  > {
    try {
      return await this.contract.getFunction("stakingPeriod(uint256)")(
        arg0,
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async tokenSplitter(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("tokenSplitter()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async totalAmountStaked(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("totalAmountStaked()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async userInfo(
    arg0: string,
    overrides?: Overrides
  ): Promise<[bigint, bigint] & { amount: bigint; rewardDebt: bigint }> {
    try {
      return await this.contract.getFunction("userInfo(address)")(
        arg0,
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async x2y2Token(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("x2y2Token()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }
}

export class X2y2BoundContractView extends BoundContractView<
  X2y2,
  X2y2ContractView
> {
  async NUMBER_PERIODS(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.NUMBER_PERIODS(overrides || {});
  }

  async PRECISION_FACTOR(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.PRECISION_FACTOR(overrides || {});
  }

  async START_BLOCK(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.START_BLOCK(overrides || {});
  }

  async accTokenPerShare(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.accTokenPerShare(overrides || {});
  }

  async calculatePendingRewards(
    user: string,
    overrides?: Overrides
  ): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.calculatePendingRewards(user, overrides || {});
  }

  async currentPhase(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.currentPhase(overrides || {});
  }

  async endBlock(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.endBlock(overrides || {});
  }

  async lastRewardBlock(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.lastRewardBlock(overrides || {});
  }

  async rewardPerBlockForOthers(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.rewardPerBlockForOthers(overrides || {});
  }

  async rewardPerBlockForStaking(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.rewardPerBlockForStaking(overrides || {});
  }

  async stakingPeriod(
    arg0: BigNumberish,
    overrides?: Overrides
  ): Promise<
    [bigint, bigint, bigint] & {
      rewardPerBlockForStaking: bigint;
      rewardPerBlockForOthers: bigint;
      periodLengthInBlock: bigint;
    }
  > {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.stakingPeriod(arg0, overrides || {});
  }

  async tokenSplitter(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.tokenSplitter(overrides || {});
  }

  async totalAmountStaked(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.totalAmountStaked(overrides || {});
  }

  async userInfo(
    arg0: string,
    overrides?: Overrides
  ): Promise<[bigint, bigint] & { amount: bigint; rewardDebt: bigint }> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.userInfo(arg0, overrides || {});
  }

  async x2y2Token(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.x2y2Token(overrides || {});
  }
}

export type X2y2Context = ContractContext<X2y2, X2y2BoundContractView>;

export class X2y2Processor extends BaseProcessor<X2y2, X2y2BoundContractView> {
  onEventCompound(
    handler: (event: CompoundEvent, ctx: X2y2Context) => void,
    filter?: CompoundEventFilter | CompoundEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Compound(address,uint256)"](
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventDeposit(
    handler: (event: DepositEvent, ctx: X2y2Context) => void,
    filter?: DepositEventFilter | DepositEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Deposit(address,uint256,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventNewRewardsPerBlock(
    handler: (event: NewRewardsPerBlockEvent, ctx: X2y2Context) => void,
    filter?: NewRewardsPerBlockEventFilter | NewRewardsPerBlockEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "NewRewardsPerBlock(uint256,uint256,uint256,uint256)"
      ](null, null, null, null);
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventWithdraw(
    handler: (event: WithdrawEvent, ctx: X2y2Context) => void,
    filter?: WithdrawEventFilter | WithdrawEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Withdraw(address,uint256,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onCallNUMBER_PERIODS(
    handler: (call: NUMBER_PERIODSCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x52bf348c", handler as any, fetchConfig);
  }

  onCallPRECISION_FACTOR(
    handler: (call: PRECISION_FACTORCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xccd34cd5", handler as any, fetchConfig);
  }

  onCallSTART_BLOCK(
    handler: (call: START_BLOCKCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x39b3e826", handler as any, fetchConfig);
  }

  onCallAccTokenPerShare(
    handler: (call: AccTokenPerShareCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x8f662915", handler as any, fetchConfig);
  }

  onCallCalculatePendingRewards(
    handler: (call: CalculatePendingRewardsCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x097aad10", handler as any, fetchConfig);
  }

  onCallCurrentPhase(
    handler: (call: CurrentPhaseCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x055ad42e", handler as any, fetchConfig);
  }

  onCallDeposit(
    handler: (call: DepositCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xb6b55f25", handler as any, fetchConfig);
  }

  onCallEndBlock(
    handler: (call: EndBlockCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x083c6323", handler as any, fetchConfig);
  }

  onCallHarvestAndCompound(
    handler: (call: HarvestAndCompoundCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x2a4e051b", handler as any, fetchConfig);
  }

  onCallLastRewardBlock(
    handler: (call: LastRewardBlockCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xa9f8d181", handler as any, fetchConfig);
  }

  onCallRewardPerBlockForOthers(
    handler: (call: RewardPerBlockForOthersCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xe683d96f", handler as any, fetchConfig);
  }

  onCallRewardPerBlockForStaking(
    handler: (
      call: RewardPerBlockForStakingCallTrace,
      ctx: X2y2Context
    ) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x5a9477e9", handler as any, fetchConfig);
  }

  onCallStakingPeriod(
    handler: (call: StakingPeriodCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xc1027c98", handler as any, fetchConfig);
  }

  onCallTokenSplitter(
    handler: (call: TokenSplitterCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xa46074c3", handler as any, fetchConfig);
  }

  onCallTotalAmountStaked(
    handler: (call: TotalAmountStakedCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xfe961f61", handler as any, fetchConfig);
  }

  onCallUpdatePool(
    handler: (call: UpdatePoolCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xe3161ddd", handler as any, fetchConfig);
  }

  onCallUserInfo(
    handler: (call: UserInfoCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x1959a002", handler as any, fetchConfig);
  }

  onCallWithdraw(
    handler: (call: WithdrawCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x2e1a7d4d", handler as any, fetchConfig);
  }

  onCallWithdrawAll(
    handler: (call: WithdrawAllCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x853828b6", handler as any, fetchConfig);
  }

  onCallX2y2Token(
    handler: (call: X2y2TokenCallTrace, ctx: X2y2Context) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xebde5ee6", handler as any, fetchConfig);
  }

  public static filters = {
    Compound(user?: string | null, harvestedAmount?: null) {
      return templateContract.filters["Compound(address,uint256)"](
        user,
        harvestedAmount
      );
    },
    Deposit(user?: string | null, amount?: null, harvestedAmount?: null) {
      return templateContract.filters["Deposit(address,uint256,uint256)"](
        user,
        amount,
        harvestedAmount
      );
    },
    NewRewardsPerBlock(
      currentPhase?: BigNumberish | null,
      startBlock?: null,
      rewardPerBlockForStaking?: null,
      rewardPerBlockForOthers?: null
    ) {
      return templateContract.filters[
        "NewRewardsPerBlock(uint256,uint256,uint256,uint256)"
      ](
        currentPhase,
        startBlock,
        rewardPerBlockForStaking,
        rewardPerBlockForOthers
      );
    },
    Withdraw(user?: string | null, amount?: null, harvestedAmount?: null) {
      return templateContract.filters["Withdraw(address,uint256,uint256)"](
        user,
        amount,
        harvestedAmount
      );
    },
  };

  protected CreateBoundContractView(): X2y2BoundContractView {
    const view = getX2y2Contract(this.config.network, this.config.address);
    return new X2y2BoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): X2y2Processor {
    if (!options.name) {
      options.name = "X2y2";
    }
    let processor = getProcessor(options) as X2y2Processor;
    if (!processor) {
      processor = new X2y2Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class X2y2ProcessorTemplate extends BaseProcessorTemplate<
  X2y2,
  X2y2BoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "X2y2";
    }
    let processor = getProcessor(options) as X2y2Processor;
    if (!processor) {
      processor = new X2y2Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventCompound(
    handler: (event: CompoundEvent, ctx: X2y2Context) => void,
    filter?: CompoundEventFilter | CompoundEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Compound(address,uint256)"](
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventDeposit(
    handler: (event: DepositEvent, ctx: X2y2Context) => void,
    filter?: DepositEventFilter | DepositEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Deposit(address,uint256,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventNewRewardsPerBlock(
    handler: (event: NewRewardsPerBlockEvent, ctx: X2y2Context) => void,
    filter?: NewRewardsPerBlockEventFilter | NewRewardsPerBlockEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "NewRewardsPerBlock(uint256,uint256,uint256,uint256)"
      ](null, null, null, null);
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventWithdraw(
    handler: (event: WithdrawEvent, ctx: X2y2Context) => void,
    filter?: WithdrawEventFilter | WithdrawEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Withdraw(address,uint256,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }
}

export function getX2y2Contract(
  contextOrNetwork: BaseContext | Networkish,
  address: string
): X2y2ContractView {
  const network = getNetworkFromCtxOrNetworkish(contextOrNetwork);
  let contract = getContractByABI("X2y2", address, network) as X2y2ContractView;
  if (!contract) {
    const rawContract = X2y2__factory.connect(address, getProvider(network));
    contract = new X2y2ContractView(rawContract);
    addContractByABI("X2y2", address, network, contract);
  }
  return contract;
}
