/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { Overrides } from "ethers";
import { Networkish } from "ethers/providers";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  TypedCallTrace,
  getNetworkFromCtxOrNetworkish,
} from "@sentio/sdk/eth";
import { BaseContext } from "@sentio/sdk";
import { EthFetchConfig } from "@sentio/protos";

import { Sushipair, Sushipair__factory } from "./index.js";
import {
  ApprovalEvent,
  ApprovalEventFilter,
  BurnEvent,
  BurnEventFilter,
  MintEvent,
  MintEventFilter,
  SwapEvent,
  SwapEventFilter,
  SyncEvent,
  SyncEventFilter,
  TransferEvent,
  TransferEventFilter,
} from "./Sushipair.js";

export interface DOMAIN_SEPARATORCallObject {}

export type DOMAIN_SEPARATORCallTrace = TypedCallTrace<
  [],
  DOMAIN_SEPARATORCallObject
>;

export interface MINIMUM_LIQUIDITYCallObject {}

export type MINIMUM_LIQUIDITYCallTrace = TypedCallTrace<
  [],
  MINIMUM_LIQUIDITYCallObject
>;

export interface PERMIT_TYPEHASHCallObject {}

export type PERMIT_TYPEHASHCallTrace = TypedCallTrace<
  [],
  PERMIT_TYPEHASHCallObject
>;

export interface AllowanceCallObject {}

export type AllowanceCallTrace = TypedCallTrace<
  [string, string],
  AllowanceCallObject
>;

export interface ApproveCallObject {
  spender: string;
  value: bigint;
}

export type ApproveCallTrace = TypedCallTrace<
  [string, bigint],
  ApproveCallObject
>;

export interface BalanceOfCallObject {}

export type BalanceOfCallTrace = TypedCallTrace<[string], BalanceOfCallObject>;

export interface BurnCallObject {
  to: string;
}

export type BurnCallTrace = TypedCallTrace<[string], BurnCallObject>;

export interface DecimalsCallObject {}

export type DecimalsCallTrace = TypedCallTrace<[], DecimalsCallObject>;

export interface FactoryCallObject {}

export type FactoryCallTrace = TypedCallTrace<[], FactoryCallObject>;

export interface GetReservesCallObject {}

export type GetReservesCallTrace = TypedCallTrace<[], GetReservesCallObject>;

export interface InitializeCallObject {
  _token0: string;
  _token1: string;
}

export type InitializeCallTrace = TypedCallTrace<
  [string, string],
  InitializeCallObject
>;

export interface KLastCallObject {}

export type KLastCallTrace = TypedCallTrace<[], KLastCallObject>;

export interface MintCallObject {
  to: string;
}

export type MintCallTrace = TypedCallTrace<[string], MintCallObject>;

export interface NameCallObject {}

export type NameCallTrace = TypedCallTrace<[], NameCallObject>;

export interface NoncesCallObject {}

export type NoncesCallTrace = TypedCallTrace<[string], NoncesCallObject>;

export interface PermitCallObject {
  owner: string;
  spender: string;
  value: bigint;
  deadline: bigint;
  v: bigint;
  r: string;
  s: string;
}

export type PermitCallTrace = TypedCallTrace<
  [string, string, bigint, bigint, bigint, string, string],
  PermitCallObject
>;

export interface Price0CumulativeLastCallObject {}

export type Price0CumulativeLastCallTrace = TypedCallTrace<
  [],
  Price0CumulativeLastCallObject
>;

export interface Price1CumulativeLastCallObject {}

export type Price1CumulativeLastCallTrace = TypedCallTrace<
  [],
  Price1CumulativeLastCallObject
>;

export interface SkimCallObject {
  to: string;
}

export type SkimCallTrace = TypedCallTrace<[string], SkimCallObject>;

export interface SwapCallObject {
  amount0Out: bigint;
  amount1Out: bigint;
  to: string;
  data: string;
}

export type SwapCallTrace = TypedCallTrace<
  [bigint, bigint, string, string],
  SwapCallObject
>;

export interface SymbolCallObject {}

export type SymbolCallTrace = TypedCallTrace<[], SymbolCallObject>;

export interface SyncCallObject {}

export type SyncCallTrace = TypedCallTrace<[], SyncCallObject>;

export interface Token0CallObject {}

export type Token0CallTrace = TypedCallTrace<[], Token0CallObject>;

export interface Token1CallObject {}

export type Token1CallTrace = TypedCallTrace<[], Token1CallObject>;

export interface TotalSupplyCallObject {}

export type TotalSupplyCallTrace = TypedCallTrace<[], TotalSupplyCallObject>;

export interface TransferCallObject {
  to: string;
  value: bigint;
}

export type TransferCallTrace = TypedCallTrace<
  [string, bigint],
  TransferCallObject
>;

export interface TransferFromCallObject {
  from: string;
  to: string;
  value: bigint;
}

export type TransferFromCallTrace = TypedCallTrace<
  [string, string, bigint],
  TransferFromCallObject
>;

const templateContract = Sushipair__factory.connect("0x0", DummyProvider);

export class SushipairContractView extends ContractView<Sushipair> {
  constructor(contract: Sushipair) {
    super(contract);
  }

  async DOMAIN_SEPARATOR(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("DOMAIN_SEPARATOR()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async MINIMUM_LIQUIDITY(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("MINIMUM_LIQUIDITY()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async PERMIT_TYPEHASH(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("PERMIT_TYPEHASH()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async allowance(
    arg0: string,
    arg1: string,
    overrides?: Overrides
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("allowance(address,address)")(
        arg0,
        arg1,
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async balanceOf(arg0: string, overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address)")(
        arg0,
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async decimals(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("decimals()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async factory(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("factory()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async getReserves(
    overrides?: Overrides
  ): Promise<
    [bigint, bigint, bigint] & {
      _reserve0: bigint;
      _reserve1: bigint;
      _blockTimestampLast: bigint;
    }
  > {
    try {
      return await this.contract.getFunction("getReserves()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async kLast(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("kLast()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async name(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("name()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async nonces(arg0: string, overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("nonces(address)")(
        arg0,
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async price0CumulativeLast(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("price0CumulativeLast()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async price1CumulativeLast(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("price1CumulativeLast()")(
        overrides || {}
      );
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async symbol(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("symbol()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async token0(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("token0()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async token1(overrides?: Overrides): Promise<string> {
    try {
      return await this.contract.getFunction("token1()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }

  async totalSupply(overrides?: Overrides): Promise<bigint> {
    try {
      return await this.contract.getFunction("totalSupply()")(overrides || {});
    } catch (e) {
      throw transformEtherError(e, undefined);
    }
  }
}

export class SushipairBoundContractView extends BoundContractView<
  Sushipair,
  SushipairContractView
> {
  async DOMAIN_SEPARATOR(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.DOMAIN_SEPARATOR(overrides || {});
  }

  async MINIMUM_LIQUIDITY(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.MINIMUM_LIQUIDITY(overrides || {});
  }

  async PERMIT_TYPEHASH(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.PERMIT_TYPEHASH(overrides || {});
  }

  async allowance(
    arg0: string,
    arg1: string,
    overrides?: Overrides
  ): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.allowance(arg0, arg1, overrides || {});
  }

  async balanceOf(arg0: string, overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.balanceOf(arg0, overrides || {});
  }

  async decimals(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.decimals(overrides || {});
  }

  async factory(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.factory(overrides || {});
  }

  async getReserves(
    overrides?: Overrides
  ): Promise<
    [bigint, bigint, bigint] & {
      _reserve0: bigint;
      _reserve1: bigint;
      _blockTimestampLast: bigint;
    }
  > {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.getReserves(overrides || {});
  }

  async kLast(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.kLast(overrides || {});
  }

  async name(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.name(overrides || {});
  }

  async nonces(arg0: string, overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.nonces(arg0, overrides || {});
  }

  async price0CumulativeLast(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.price0CumulativeLast(overrides || {});
  }

  async price1CumulativeLast(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.price1CumulativeLast(overrides || {});
  }

  async symbol(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.symbol(overrides || {});
  }

  async token0(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.token0(overrides || {});
  }

  async token1(overrides?: Overrides): Promise<string> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.token1(overrides || {});
  }

  async totalSupply(overrides?: Overrides): Promise<bigint> {
    if (!overrides && this.context) {
      overrides = {
        blockTag: this.context.blockNumber,
      };
    }
    return await this.view.totalSupply(overrides || {});
  }
}

export type SushipairContext = ContractContext<
  Sushipair,
  SushipairBoundContractView
>;

export class SushipairProcessor extends BaseProcessor<
  Sushipair,
  SushipairBoundContractView
> {
  onEventApproval(
    handler: (event: ApprovalEvent, ctx: SushipairContext) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventBurn(
    handler: (event: BurnEvent, ctx: SushipairContext) => void,
    filter?: BurnEventFilter | BurnEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "Burn(address,uint256,uint256,address)"
      ](null, null, null, null);
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventMint(
    handler: (event: MintEvent, ctx: SushipairContext) => void,
    filter?: MintEventFilter | MintEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Mint(address,uint256,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventSwap(
    handler: (event: SwapEvent, ctx: SushipairContext) => void,
    filter?: SwapEventFilter | SwapEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "Swap(address,uint256,uint256,uint256,uint256,address)"
      ](null, null, null, null, null, null);
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventSync(
    handler: (event: SyncEvent, ctx: SushipairContext) => void,
    filter?: SyncEventFilter | SyncEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Sync(uint112,uint112)"](null, null);
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: SushipairContext) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onCallDOMAIN_SEPARATOR(
    handler: (call: DOMAIN_SEPARATORCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x3644e515", handler as any, fetchConfig);
  }

  onCallMINIMUM_LIQUIDITY(
    handler: (call: MINIMUM_LIQUIDITYCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xba9a7a56", handler as any, fetchConfig);
  }

  onCallPERMIT_TYPEHASH(
    handler: (call: PERMIT_TYPEHASHCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x30adf81f", handler as any, fetchConfig);
  }

  onCallAllowance(
    handler: (call: AllowanceCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xdd62ed3e", handler as any, fetchConfig);
  }

  onCallApprove(
    handler: (call: ApproveCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x095ea7b3", handler as any, fetchConfig);
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x70a08231", handler as any, fetchConfig);
  }

  onCallBurn(
    handler: (call: BurnCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x89afcb44", handler as any, fetchConfig);
  }

  onCallDecimals(
    handler: (call: DecimalsCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x313ce567", handler as any, fetchConfig);
  }

  onCallFactory(
    handler: (call: FactoryCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xc45a0155", handler as any, fetchConfig);
  }

  onCallGetReserves(
    handler: (call: GetReservesCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x0902f1ac", handler as any, fetchConfig);
  }

  onCallInitialize(
    handler: (call: InitializeCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x485cc955", handler as any, fetchConfig);
  }

  onCallKLast(
    handler: (call: KLastCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x7464fc3d", handler as any, fetchConfig);
  }

  onCallMint(
    handler: (call: MintCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x6a627842", handler as any, fetchConfig);
  }

  onCallName(
    handler: (call: NameCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x06fdde03", handler as any, fetchConfig);
  }

  onCallNonces(
    handler: (call: NoncesCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x7ecebe00", handler as any, fetchConfig);
  }

  onCallPermit(
    handler: (call: PermitCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xd505accf", handler as any, fetchConfig);
  }

  onCallPrice0CumulativeLast(
    handler: (
      call: Price0CumulativeLastCallTrace,
      ctx: SushipairContext
    ) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x5909c0d5", handler as any, fetchConfig);
  }

  onCallPrice1CumulativeLast(
    handler: (
      call: Price1CumulativeLastCallTrace,
      ctx: SushipairContext
    ) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x5a3d5493", handler as any, fetchConfig);
  }

  onCallSkim(
    handler: (call: SkimCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xbc25cf77", handler as any, fetchConfig);
  }

  onCallSwap(
    handler: (call: SwapCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x022c0d9f", handler as any, fetchConfig);
  }

  onCallSymbol(
    handler: (call: SymbolCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x95d89b41", handler as any, fetchConfig);
  }

  onCallSync(
    handler: (call: SyncCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xfff6cae9", handler as any, fetchConfig);
  }

  onCallToken0(
    handler: (call: Token0CallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x0dfe1681", handler as any, fetchConfig);
  }

  onCallToken1(
    handler: (call: Token1CallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xd21220a7", handler as any, fetchConfig);
  }

  onCallTotalSupply(
    handler: (call: TotalSupplyCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x18160ddd", handler as any, fetchConfig);
  }

  onCallTransfer(
    handler: (call: TransferCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0xa9059cbb", handler as any, fetchConfig);
  }

  onCallTransferFrom(
    handler: (call: TransferFromCallTrace, ctx: SushipairContext) => void,
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    return super.onTrace("0x23b872dd", handler as any, fetchConfig);
  }

  public static filters = {
    Approval(owner?: string | null, spender?: string | null, value?: null) {
      return templateContract.filters["Approval(address,address,uint256)"](
        owner,
        spender,
        value
      );
    },
    Burn(
      sender?: string | null,
      amount0?: null,
      amount1?: null,
      to?: string | null
    ) {
      return templateContract.filters["Burn(address,uint256,uint256,address)"](
        sender,
        amount0,
        amount1,
        to
      );
    },
    Mint(sender?: string | null, amount0?: null, amount1?: null) {
      return templateContract.filters["Mint(address,uint256,uint256)"](
        sender,
        amount0,
        amount1
      );
    },
    Swap(
      sender?: string | null,
      amount0In?: null,
      amount1In?: null,
      amount0Out?: null,
      amount1Out?: null,
      to?: string | null
    ) {
      return templateContract.filters[
        "Swap(address,uint256,uint256,uint256,uint256,address)"
      ](sender, amount0In, amount1In, amount0Out, amount1Out, to);
    },
    Sync(reserve0?: null, reserve1?: null) {
      return templateContract.filters["Sync(uint112,uint112)"](
        reserve0,
        reserve1
      );
    },
    Transfer(from?: string | null, to?: string | null, value?: null) {
      return templateContract.filters["Transfer(address,address,uint256)"](
        from,
        to,
        value
      );
    },
  };

  protected CreateBoundContractView(): SushipairBoundContractView {
    const view = getSushipairContract(this.config.network, this.config.address);
    return new SushipairBoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): SushipairProcessor {
    if (!options.name) {
      options.name = "Sushipair";
    }
    let processor = getProcessor(options) as SushipairProcessor;
    if (!processor) {
      processor = new SushipairProcessor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class SushipairProcessorTemplate extends BaseProcessorTemplate<
  Sushipair,
  SushipairBoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "Sushipair";
    }
    let processor = getProcessor(options) as SushipairProcessor;
    if (!processor) {
      processor = new SushipairProcessor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApproval(
    handler: (event: ApprovalEvent, ctx: SushipairContext) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventBurn(
    handler: (event: BurnEvent, ctx: SushipairContext) => void,
    filter?: BurnEventFilter | BurnEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "Burn(address,uint256,uint256,address)"
      ](null, null, null, null);
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventMint(
    handler: (event: MintEvent, ctx: SushipairContext) => void,
    filter?: MintEventFilter | MintEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Mint(address,uint256,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventSwap(
    handler: (event: SwapEvent, ctx: SushipairContext) => void,
    filter?: SwapEventFilter | SwapEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "Swap(address,uint256,uint256,uint256,uint256,address)"
      ](null, null, null, null, null, null);
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventSync(
    handler: (event: SyncEvent, ctx: SushipairContext) => void,
    filter?: SyncEventFilter | SyncEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Sync(uint112,uint112)"](null, null);
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: SushipairContext) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEvent(handler, filter!, fetchConfig);
  }
}

export function getSushipairContract(
  contextOrNetwork: BaseContext | Networkish,
  address: string
): SushipairContractView {
  const network = getNetworkFromCtxOrNetworkish(contextOrNetwork);
  let contract = getContractByABI(
    "Sushipair",
    address,
    network
  ) as SushipairContractView;
  if (!contract) {
    const rawContract = Sushipair__factory.connect(
      address,
      getProvider(network)
    );
    contract = new SushipairContractView(rawContract);
    addContractByABI("Sushipair", address, network, contract);
  }
  return contract;
}
